"""
End-to-End Integration Tests

Tests the unified provisioning service layer with real Keycloak stack.
These tests validate the complete flow: UI → Service → JML → Keycloak.

Prerequisites:
    - Docker stack running (make quickstart)
    - Keycloak available at $KEYCLOAK_URL
    - Service account credentials configured

Usage:
    # Run with real Keycloak stack
    make quickstart
    pytest tests/test_integration_e2e.py -v

    # Skip integration tests during CI
    pytest -m "not integration" tests/
"""

import os
import pytest
import requests
from datetime import datetime

# Mark all tests in this file as integration tests
pytestmark = pytest.mark.integration

# Environment variables (from .env via make)
KEYCLOAK_URL = os.getenv("KEYCLOAK_URL", "https://localhost")
APP_BASE_URL = os.getenv("APP_BASE_URL", "https://localhost")
SERVICE_CLIENT_ID = os.getenv("KEYCLOAK_SERVICE_CLIENT_ID", "automation-cli")
SERVICE_CLIENT_SECRET = os.getenv("KEYCLOAK_SERVICE_CLIENT_SECRET", "")
SERVICE_REALM = os.getenv("KEYCLOAK_SERVICE_REALM", "demo")

# Skip all tests if service secret not configured
pytestmark = pytest.mark.skipif(
    not SERVICE_CLIENT_SECRET,
    reason="KEYCLOAK_SERVICE_CLIENT_SECRET not configured"
)


# ============================================================================
# Fixtures
# ============================================================================

@pytest.fixture(scope="module")
def auth_token():
    """Get OAuth Bearer token from Keycloak"""
    token_url = f"{KEYCLOAK_URL}/realms/{SERVICE_REALM}/protocol/openid-connect/token"
    
    response = requests.post(
        token_url,
        data={
            "grant_type": "client_credentials",
            "client_id": SERVICE_CLIENT_ID,
            "client_secret": SERVICE_CLIENT_SECRET,
        },
        verify=False,  # Self-signed cert in dev
    )
    
    assert response.status_code == 200, f"Failed to get token: {response.text}"
    token_data = response.json()
    return token_data["access_token"]


@pytest.fixture
def scim_headers(auth_token):
    """SCIM API request headers"""
    return {
        "Authorization": f"Bearer {auth_token}",
        "Content-Type": "application/scim+json",
        "Accept": "application/scim+json",
        "X-Correlation-Id": f"e2e-test-{datetime.now().timestamp()}",
    }


@pytest.fixture
def test_username():
    """Generate unique test username"""
    timestamp = int(datetime.now().timestamp())
    return f"e2e_user_{timestamp}"


# ============================================================================
# E2E Test: Full CRUD Flow via SCIM API
# ============================================================================

def test_e2e_crud_flow_scim_api(scim_headers, test_username):
    """
    End-to-end test: Create → Get → List → Update → Delete user via SCIM API
    
    This test validates:
    - provisioning_service.py business logic
    - scim_api.py HTTP layer
    - scripts/jml.py Keycloak integration
    - Session revocation on delete
    """
    base_url = f"{APP_BASE_URL}/scim/v2/Users"
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 1: Create User (Joiner)
    # ─────────────────────────────────────────────────────────────────────
    create_payload = {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": test_username,
        "emails": [{"value": f"{test_username}@example.com", "primary": True}],
        "name": {"givenName": "E2E", "familyName": "Test"},
        "active": True,
    }
    
    response = requests.post(base_url, json=create_payload, headers=scim_headers, verify=False)
    assert response.status_code == 201, f"Create failed: {response.text}"
    
    created_user = response.json()
    user_id = created_user["id"]
    
    assert created_user["schemas"] == ["urn:ietf:params:scim:schemas:core:2.0:User"]
    assert created_user["userName"] == test_username
    assert created_user["emails"][0]["value"] == f"{test_username}@example.com"
    assert created_user["name"]["givenName"] == "E2E"
    assert created_user["active"] is True
    assert "meta" in created_user
    assert created_user["meta"]["resourceType"] == "User"
    
    print(f"✅ Created user: {user_id}")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 2: Get User by ID
    # ─────────────────────────────────────────────────────────────────────
    response = requests.get(f"{base_url}/{user_id}", headers=scim_headers, verify=False)
    assert response.status_code == 200, f"Get failed: {response.text}"
    
    retrieved_user = response.json()
    assert retrieved_user["id"] == user_id
    assert retrieved_user["userName"] == test_username
    assert "_tempPassword" not in retrieved_user  # Never in GET response
    
    print(f"✅ Retrieved user: {user_id}")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 3: List Users (filter by userName)
    # ─────────────────────────────────────────────────────────────────────
    filter_query = f'userName eq "{test_username}"'
    response = requests.get(
        base_url,
        params={"filter": filter_query},
        headers=scim_headers,
        verify=False
    )
    assert response.status_code == 200, f"List failed: {response.text}"
    
    list_result = response.json()
    assert list_result["schemas"] == ["urn:ietf:params:scim:api:messages:2.0:ListResponse"]
    assert list_result["totalResults"] >= 1
    
    # Find our user in results
    found = False
    for resource in list_result["Resources"]:
        if resource["id"] == user_id:
            found = True
            assert resource["userName"] == test_username
            break
    
    assert found, f"User {user_id} not found in list results"
    print(f"✅ Listed user: {user_id}")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 4: Update User (PUT - change name)
    # ─────────────────────────────────────────────────────────────────────
    update_payload = created_user.copy()
    update_payload["name"]["familyName"] = "Updated"
    
    response = requests.put(
        f"{base_url}/{user_id}",
        json=update_payload,
        headers=scim_headers,
        verify=False
    )
    assert response.status_code == 200, f"Update failed: {response.text}"
    
    updated_user = response.json()
    assert updated_user["name"]["familyName"] == "Updated"
    
    print(f"✅ Updated user: {user_id}")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 5: Disable User (PUT with active=false)
    # ─────────────────────────────────────────────────────────────────────
    disable_payload = updated_user.copy()
    disable_payload["active"] = False
    
    response = requests.put(
        f"{base_url}/{user_id}",
        json=disable_payload,
        headers=scim_headers,
        verify=False
    )
    assert response.status_code == 200, f"Disable failed: {response.text}"
    
    disabled_user = response.json()
    assert disabled_user["active"] is False
    
    print(f"✅ Disabled user: {user_id} (sessions revoked)")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 6: Delete User (soft delete)
    # ─────────────────────────────────────────────────────────────────────
    response = requests.delete(f"{base_url}/{user_id}", headers=scim_headers, verify=False)
    assert response.status_code == 204, f"Delete failed: {response.text}"
    
    print(f"✅ Deleted user: {user_id}")
    
    # ─────────────────────────────────────────────────────────────────────
    # Step 7: Verify user still exists but disabled (idempotent delete)
    # ─────────────────────────────────────────────────────────────────────
    response = requests.get(f"{base_url}/{user_id}", headers=scim_headers, verify=False)
    assert response.status_code == 200, "User should still exist after soft delete"
    
    final_user = response.json()
    assert final_user["active"] is False, "User should be disabled"
    
    print(f"✅ Verified user disabled (soft delete): {user_id}")


# ============================================================================
# E2E Test: Error Handling
# ============================================================================

def test_e2e_error_handling(scim_headers, test_username):
    """Test SCIM error responses (400, 404, 409)"""
    base_url = f"{APP_BASE_URL}/scim/v2/Users"
    
    # ─────────────────────────────────────────────────────────────────────
    # Test 1: Create user with missing userName (400)
    # ─────────────────────────────────────────────────────────────────────
    invalid_payload = {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        # Missing userName
        "emails": [{"value": "test@example.com"}],
        "active": True,
    }
    
    response = requests.post(base_url, json=invalid_payload, headers=scim_headers, verify=False)
    assert response.status_code == 400, "Should return 400 for missing userName"
    
    error = response.json()
    assert error["schemas"] == ["urn:ietf:params:scim:api:messages:2.0:Error"]
    assert error["status"] == "400"
    assert "userName" in error["detail"]
    assert error["scimType"] == "invalidValue"
    
    print("✅ Validated 400 error for missing userName")
    
    # ─────────────────────────────────────────────────────────────────────
    # Test 2: Get non-existent user (404)
    # ─────────────────────────────────────────────────────────────────────
    fake_id = "00000000-0000-0000-0000-000000000000"
    response = requests.get(f"{base_url}/{fake_id}", headers=scim_headers, verify=False)
    assert response.status_code == 404, "Should return 404 for non-existent user"
    
    error = response.json()
    assert error["schemas"] == ["urn:ietf:params:scim:api:messages:2.0:Error"]
    assert error["status"] == "404"
    
    print("✅ Validated 404 error for non-existent user")
    
    # ─────────────────────────────────────────────────────────────────────
    # Test 3: Create duplicate user (409)
    # ─────────────────────────────────────────────────────────────────────
    # First create a user
    create_payload = {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": test_username,
        "emails": [{"value": f"{test_username}@example.com"}],
        "name": {"givenName": "Test", "familyName": "User"},
        "active": True,
    }
    
    response1 = requests.post(base_url, json=create_payload, headers=scim_headers, verify=False)
    assert response1.status_code == 201, "First create should succeed"
    user_id = response1.json()["id"]
    
    # Try to create duplicate
    response2 = requests.post(base_url, json=create_payload, headers=scim_headers, verify=False)
    assert response2.status_code == 409, "Should return 409 for duplicate userName"
    
    error = response2.json()
    assert error["schemas"] == ["urn:ietf:params:scim:api:messages:2.0:Error"]
    assert error["status"] == "409"
    assert error["scimType"] == "uniqueness"
    
    print("✅ Validated 409 error for duplicate userName")
    
    # Cleanup
    requests.delete(f"{base_url}/{user_id}", headers=scim_headers, verify=False)


# ============================================================================
# E2E Test: DOGFOOD Mode (UI calls SCIM API)
# ============================================================================

@pytest.mark.skipif(
    os.getenv("DOGFOOD_SCIM") != "true",
    reason="DOGFOOD_SCIM not enabled"
)
def test_e2e_dogfood_mode(test_username):
    """
    Test DOGFOOD mode: Flask UI routes call SCIM API via HTTP
    
    Prerequisites:
        - export DOGFOOD_SCIM=true
        - Flask app running with authenticated session
    
    Note: This test requires manual browser session setup,
          so it's marked as skipif by default.
    """
    # This would require setting up a Flask test client with authenticated session
    # For now, we document the manual test procedure:
    pytest.skip("DOGFOOD mode requires authenticated UI session - test manually")
    
    # Manual test procedure:
    # 1. export DOGFOOD_SCIM=true
    # 2. make quickstart
    # 3. Login to UI as realm-admin
    # 4. Use /admin/joiner to create user
    # 5. Check logs for "[dogfood] Created user via SCIM API"


# ============================================================================
# E2E Test: ServiceProviderConfig (SCIM discovery)
# ============================================================================

def test_e2e_service_provider_config(scim_headers):
    """Test SCIM ServiceProviderConfig endpoint"""
    url = f"{APP_BASE_URL}/scim/v2/ServiceProviderConfig"
    
    response = requests.get(url, headers=scim_headers, verify=False)
    assert response.status_code == 200
    
    config = response.json()
    assert config["schemas"] == ["urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig"]
    assert "patch" in config
    assert "bulk" in config
    assert "filter" in config
    assert config["filter"]["supported"] is True
    
    print("✅ ServiceProviderConfig endpoint validated")


# ============================================================================
# E2E Test: Pagination
# ============================================================================

def test_e2e_pagination(scim_headers):
    """Test SCIM list with pagination parameters"""
    base_url = f"{APP_BASE_URL}/scim/v2/Users"
    
    # Request first page
    response = requests.get(
        base_url,
        params={"startIndex": 1, "count": 5},
        headers=scim_headers,
        verify=False
    )
    assert response.status_code == 200
    
    result = response.json()
    assert result["schemas"] == ["urn:ietf:params:scim:api:messages:2.0:ListResponse"]
    assert result["startIndex"] == 1
    assert result["itemsPerPage"] <= 5
    assert "totalResults" in result
    
    print(f"✅ Pagination validated (totalResults: {result['totalResults']})")


# ============================================================================
# Test Configuration
# ============================================================================

@pytest.fixture(autouse=True, scope="session")
def suppress_insecure_warnings():
    """Suppress SSL warnings for self-signed certs in dev"""
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
