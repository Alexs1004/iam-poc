# Troubleshooting Guide

## Common Issues and Solutions

### "Invalid client credentials" after `make fresh-demo`

**Symptom**: Admin UI shows "Unable to load Keycloak state" or 401 errors after running `make fresh-demo`.

**Cause**: 
- `scripts/demo_jml.sh` generates random secrets for automation-cli client in Keycloak
- Application expects `demo-service-secret` (hardcoded for production mode with Azure KV)
- Docker secret file `.runtime/secrets/keycloak_service_client_secret` gets out of sync

**Solution**:
```bash
# Quick fix: Run the secret synchronization script
docker compose exec flask-app python3 /srv/app/scripts/fix_automation_cli_secret.py

# Manual fix: Update Docker secret file
sudo bash -c 'echo -n "demo-service-secret" > .runtime/secrets/keycloak_service_client_secret'
docker compose restart flask-app
```

**Permanent fix**: The `demo_jml.sh` script (v2.0+) automatically restores `demo-service-secret` after bootstrap by loading the admin password from `.runtime/secrets/keycloak_admin_password`.

**Why this happened**:
- BEFORE PyJWKClient: `verify_signature=False` masked credential mismatches (security hole)
- AFTER PyJWKClient: Strict JWT validation correctly rejects invalid credentials
- This is **good security** - the system now catches configuration errors

---

### JWT Signature Validation Errors

**Symptom**: SCIM API returns 401 with "Invalid signature" or "Invalid token".

**Cause**: PyJWKClient validates RSA signatures against Keycloak JWKS endpoint.

**Solutions**:
1. **Token expired**: Obtain a new token from `/realms/demo/protocol/openid-connect/token`
2. **Wrong issuer**: Ensure token was issued by `https://localhost/realms/demo` (not `http://keycloak:8080/...`)
3. **JWKS cache stale**: Restart Flask app to clear JWKS cache (1-hour lifespan)

**Debug**:
```bash
# Check JWKS endpoint is accessible
curl -k https://localhost/realms/demo/protocol/openid-connect/certs

# Decode JWT without verification (for debugging only)
python3 -c "import jwt, sys; print(jwt.decode(sys.argv[1], options={'verify_signature': False}))" YOUR_TOKEN_HERE
```

---

### Azure Key Vault Connection Issues

**Symptom**: "DefaultAzureCredential failed to retrieve a token" on startup.

**Cause**: Application configured with `AZURE_USE_KEYVAULT=true` but Azure CLI not authenticated.

**Solutions**:
1. **For development**: Set `DEMO_MODE=true` in `.env` (disables Key Vault)
2. **For production**: Run `az login` before `make load-secrets`
3. **Check vault access**: Run `make doctor` to diagnose Azure connectivity

**Note**: With Docker secrets pattern, Flask doesn't need live Azure connection at runtime - secrets are pre-loaded to `.runtime/secrets/`.

---

### Demo Mode vs Production Mode Confusion

**Symptom**: Secrets not loading correctly or conflicting configurations.

**Diagnosis**:
```bash
make validate-env  # Auto-corrects DEMO_MODE/AZURE_USE_KEYVAULT conflicts
```

**Rules**:
- `DEMO_MODE=true` + `AZURE_USE_KEYVAULT=true` is **invalid** (auto-corrected)
- `DEMO_MODE=false` requires secrets in `.runtime/secrets/` (load with `make load-secrets`)
- Production mode defaults are in `.env.production` (copy to `.env`)

---

### Container Health Checks Failing

**Symptom**: `docker compose ps` shows containers as "unhealthy".

**Diagnosis**:
```bash
docker compose logs flask-app --tail=50   # Check Flask startup errors
docker compose logs keycloak --tail=50    # Check Keycloak initialization

# Test endpoints manually
docker compose exec flask-app curl http://localhost:8000/health
docker compose exec keycloak curl http://localhost:8080/health/ready
```

**Common causes**:
- Keycloak not fully started (wait 30-60s on first boot)
- Flask can't connect to Keycloak (check `KEYCLOAK_URL` in `.env`)
- Secrets missing or malformed (check `.runtime/secrets/` permissions)

---

### SCIM API Returns 403 Forbidden

**Symptom**: SCIM requests fail with `{"schemas":["urn:ietf:params:scim:api:messages:2.0:Error"],"status":"403","detail":"Forbidden"}`

**Cause**: OAuth token missing required scopes or invalid.

**Solutions**:
1. **Check scopes**: Token must include `scim` scope
   ```bash
   # Request token with scopes
   curl -X POST https://localhost/realms/demo/protocol/openid-connect/token \
     -d "grant_type=client_credentials" \
     -d "client_id=automation-cli" \
     -d "client_secret=demo-service-secret" \
     -d "scope=scim"
   ```

2. **Verify client configuration**: automation-cli must have service accounts enabled in Keycloak

---

### Self-Signed Certificate Warnings

**Symptom**: Browser shows "Your connection is not private" or curl fails with SSL errors.

**Cause**: Demo uses self-signed certificates generated by `scripts/run_https.sh`.

**Solutions**:
1. **Browser**: Click "Advanced" â†’ "Proceed to localhost" (Chrome/Edge)
2. **curl**: Use `-k` flag: `curl -k https://localhost/health`
3. **Production**: Replace `certs/localhost.{crt,key}` with CA-signed certificates

**Regenerate certificates**:
```bash
make certs  # Generates new self-signed certs (valid 30 days)
```

---

## Debugging Workflows

### Enable Debug Logging

```bash
# In .env, add:
FLASK_ENV=development
FLASK_DEBUG=true

# Restart Flask
docker compose restart flask-app
docker compose logs -f flask-app
```

### Test OAuth Flow Manually

```bash
# 1. Get service account token
TOKEN=$(curl -s -k -X POST https://localhost/realms/demo/protocol/openid-connect/token \
  -d "grant_type=client_credentials" \
  -d "client_id=automation-cli" \
  -d "client_secret=demo-service-secret" | jq -r .access_token)

# 2. Test SCIM API
curl -k -H "Authorization: Bearer $TOKEN" https://localhost/scim/v2/Users

# 3. Decode token (verify claims)
echo $TOKEN | cut -d. -f2 | base64 -d 2>/dev/null | jq
```

### Inspect Docker Secrets

```bash
# From host (requires sudo)
sudo cat .runtime/secrets/keycloak_service_client_secret

# From container
docker compose exec flask-app cat /run/secrets/keycloak_service_client_secret
```

### Reset Everything

```bash
make clean        # Remove containers + volumes
make fresh-demo   # Full reset with demo data
```

---

## Getting Help

1. **Check logs**: `make logs` or `docker compose logs -f`
2. **Validate environment**: `make validate-env`
3. **Run diagnostics**: `make doctor` (checks Azure CLI, Key Vault, Docker)
4. **Review documentation**: `README.md`, `docs/SECRET_MANAGEMENT.md`
5. **Test suite**: `make pytest` to verify core functionality

**Common log patterns to grep for**:
- Errors: `docker compose logs flask-app | grep -i error`
- OAuth: `docker compose logs flask-app | grep -i "token\|oauth\|bearer"`
- Secrets: `docker compose logs flask-app | grep -i "secret\|loaded.*from"`
